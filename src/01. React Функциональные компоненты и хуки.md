## Функциональные компоненты в React
### Хуки

<img src="assets/fc/captain.png" alt="Капитан Крюк" width="300">

Дмитрий Вайнер dmitry.weiner@gmail.com

---

### Функциональный компонент VS компонент класс

| Class | FC |
|-------|----|
|   ![Class](assets/fc/class.png)    |  ![Functional component](assets/fc/fc.png)  |

---

### Компонент-представление

#### Было

```javascript
class ShowSomething extends React.Component {
    render() {
        return <span>{this.props.somethingToShow}</span>;
    }
}
```

#### Стало

```javascript
function ShowSomething({ somethingToShow }) {
    return <span>{somethingToShow}</span>;
}
```

---

### Функциональный компонент VS компонент класс

| Class | FC |
|-------|----|
| Есть конструктор  |  Редуцирован до рендер функции  |
| Есть методы жизненного цикла | Вместо этого хуки |
| Ререндер, когда меняются props и state | Ререндер, когда меняются props и псевдостейт (useState) |


---

### Список хуков

* Базовые
  * useState
  * useEffect
  * useContext
* Дополнительные
  * useRef
  * useMemo
  * useCallback
  * useReducer
    
[Полный список](https://reactjs.org/docs/hooks-reference.html)

---

### Правила вызова хуков
* Вызовы хуков должны располагаться на первом уровне вложенности компонента-функции
* Нельзя оборачивать их в условные конструкции или циклы
* Т.к. реакту важен порядок вызова хуков, если он изменится, начнутся _странности_
[Подробнее](https://reactjs.org/docs/hooks-rules.html)

---


### Аналогии

| Class | FC |
|-------|----|
| конструктор, выполняется один раз при создании |  - |
| componentDidMount | useEffect(() => {}, [])  |
| componentWillUnmount | useEffect(() => { return () => {}}, [])  |
| this.state, setState() | useState |
| this.value | useRef |

---

### useState

```javascript
const [value, setValue] = useState(initialValue);
```

* value &mdash; текущее значение: когда меняется, происходит ререндер
* setValue(newValue) &mdash; метод установки нового значения
* setValue может принимать на вход функцию prevValue => nextValue  
* initialValue &mdash; начальное значение

---

### Было: компонент со стейтом

```javascript
class ShowSomething extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            isShowing: false
        }
    }
    render() {
        const { isShowing } = this.state;
        const { somethingToShow } = this.props;
        
        return <>
            <input 
                type="checkbox"
                value={isShowing}
                onChange={e => this.setState({ isShowing: e.target.checked })}/>
            {isShowing && (
                <span>{somethingToShow}</span>
            )}
        </>;
    }
}
```

---

### Стало: функциональный компонент со стейтом

```javascript
function ShowSomething({ somethingToShow }) {
    const [isShowing, setIsShowing] = useState(false);
    return <>
        <input
            type="checkbox"
            value={isShowing}
            onChange={e => setIsShowing(e.target.checked)}/>
        {isShowing && (
            <span>{somethingToShow}</span>
        )}
    </>;
}
```

---

### useEffect

* Выполняется после коммита рендера
* Можно имитировать методы componentDidMount и componentDidUpdate
* useEffect вызывается асинхронно, сразу после того, как применится изменение к DOM. То есть он гарантирует,
  что он будет выполнен после рендера компонента, и может привести к следующему рендеру, если какие-то 
  значения изменятся.

---

### useEffect

```javascript
useEffect(() => {
    /* effect code */ 
    return () => {/* shutdown code */};
}, [dependencies]);
```

* Принимает на вход колбек и зависимости
* Колбэк возвращает метод, который будет вызван в следующий цикл отрисовки (аналог componentWillUnmount)

---

### useEffect: особенности
* Если не передать второй параметр (или передать null), эффект будет вычисляться каждый рендер
* Если передать вторым параметром пустой массив, эффект выполнится 1 раз (componentDidMount)
* Сравнение "изменился ли" происходит по ссылке, поля объекта не сравниваются

---

### Компонент-класс Таймер
Напишем компонент в старом стиле. При монтировании этого компонента начинает идти таймер. 
При удалении таймер останавливается.
```javascript
class Timer extends React.Component {
    constructor(props) {
        super(props);
        this.state = { time: 0 };
        this.timerId = null;
    }
    componentDidMount() {
        this.timerId = setInterval(() => this.setState({ time: this.state.time + 1 }), 1000);
    }
    componentWillUnmount() {
        clearInterval(this.timerId);
    }
    render() {
        const { time } = this.state; 
        return <span>{time}</span>;
    }
}
```

---

### Функциональный компонент Таймер
Перепишем компонент в виде функции с использованием useState

Обратите внимание на переменную innerTime. Её необходимо использовать, потому что прямое использование
переменной time ссылается на замыкание, где та не меняется

---

### Функциональный компонент Таймер
```javascript
function Timer() {
    const [time, setTime] = useState(0);
    useEffect(() => {
      let innerTime = time;
      const timerId = setInterval(
              () => {
                innerTime++;
                setTime(innerTime);
              },
              1000
      );
      return () => {
        clearInterval(timerId);
      };
    }, []);
    return <span>{time}</span>;
}
```

---

### Функциональный компонент Таймер
Можно написать без добавочной переменной, используя свойство сеттера принимать на вход функцию
```javascript
function Timer() {
    const [time, setTime] = useState(0);
    useEffect(() => {
      const timerId = setInterval(
              () => setTime(time => time + 1),
              1000
      );
      return () => {
        clearInterval(timerId);
      };
    }, []);
    return <span>{time}</span>;
}
```